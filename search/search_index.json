{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Blog","text":"<p>You have somehow found my blog. You will now be subjected to posts.</p>"},{"location":"#posts","title":"Posts:","text":"<p>2023.05.14: A fast and efficient JavaScript curry implementation</p> <p>2023.04.29: Catching custom JS errors in TS</p>"},{"location":"#a-nice-picture","title":"A nice picture","text":"<p>I think this is a nice picture.</p> <p></p>"},{"location":"posts/fastJsCurry/","title":"A fast and efficient JavaScript curry implementation","text":"<p>This was a Thirty Days of JavaScript challenge over on LeetCode. It's a nice sequence, building up to harder problems and focussing on fundametals, I do recommend it!</p> <p>I was proud that I managed to work this out sans google/the editorial. It's also faster and simpler than the provided solutions and 90%+ of submissions on speed and memory efficiency. This is efficiency comes from avoiding object creation and recursion, and we don't add complexity to avoid those.</p>"},{"location":"posts/fastJsCurry/#what-the-heck-is-currying","title":"What the heck is currying?","text":"<p>If you have a function of several arguments, e.g. <code>add</code> below,it might be convenient to set the value of the first argument in a new function like <code>add2</code>.</p> <pre><code>function add(a, b) {\nreturn a + b;\n}\nadd2 = add(2); // returning add, but with a set to 2\n// which we would call like\nconsole.log(add2(4)); // 6\n</code></pre> <p>This is a nice interface when you want a more specific function derived from a more general one. The process of taking a function and making it callable in this manner is called 'currying' after Haskell Curry, who was a freak for it. Currying enables what we call partial application (like <code>add2</code>, which is a partially applied version of <code>add</code>).</p> <p>You can achieve partial application with tools like JS's <code>Function.prototype.bind()</code> and Python's <code>functools.partial()</code>, but a function <code>curry()</code> that takes a normal function like <code>add()</code> and makes it partially applyable in the manner depicted is handy -- and that's what is implemented below.</p>"},{"location":"posts/fastJsCurry/#code","title":"Code","text":"<p><pre><code>const curry = function(fn) {\nlet argsArr = new Array();\nreturn function curried(...args) {\nargsArr.push(...args);\nif (argsArr.length &gt;== fn.length) {\nreturn fn(...argsArr);\n}\nelse {\nreturn curried;\n}\n}\n}\n</code></pre> We define a closure, <code>curried()</code>, over an array where we can store arguments. Whenever the closure is called, we add the args to our array. If we have enough args in the array to call the function, we do so and return the result. If we don't, we return our closure, so that next time it's called we can collect more arguments. That's it!</p> <p>You can then use it like this:</p> <pre><code>const curry = function(fn) {\n* function sum(a, b) { return a + b; }\n* const csum = curry(sum);\n* csum(1)(2) // 3\n*/\n</code></pre> <p>Other implementations suggested over there involved a bunch of recursion and spread syntax that some people get off on, but this is easier to understand and faster.</p> <p>Bye!</p>"},{"location":"posts/handlingErrorInTS/","title":"Catching specific generic Errors in TypeScript","text":"<p>You can jump to the TL;DR to skip the discussion (and the  toilet humour, because mentally I am five).</p> <p>Everyone knows how to catch a specific error in TypeScript:</p> <pre><code>try {\nblerk = something.thatMight(throw);\n}\ncatch (e) {\nif (e instanceof FartError) {\nconsole.log('oh no somone farted');\n}\nelse {\nthrow e;\n}\n}\n</code></pre> <p>This will allow us to handle the specific error we anticipate without hiding errors we haven't anticipated. Groovy. And if you google \"How to catch a specific error in Typescript\" this is basically what the results will tell you.</p>"},{"location":"posts/handlingErrorInTS/#the-problem","title":"The problem","text":"<p>What if you want to be responsible and only catch a specific error that you have a contingency plan for, but the code you're calling doesn't inherit from Error as a way of making the error more specific. This is what I was dealing with:</p> <pre><code>import fs from 'node:fs/Promises';\ntry {\nawait f = fs.readFile('notafile.weasel');\n}\ncatch (e) {\n// here, e is Error({\n//  message: ['Error: ENOENT: no such file or directory,... ']\n//  errno: -2,\n//  code: 'ENOENT',\n//  syscall: 'open',\n//  path: '/code/notafile.weasel'\n// });\n}\n</code></pre> <p>I'm new to TypeScript so I wasn't sure how to deal with this. <code>e</code> is <code>unknown</code> when we enter a catch block, so if you do this the compliler complains:</p> <pre><code>catch (e) {\nif (e.code === 'ENOENT') { // error TS18046: 'e' is of type 'unknown'.\nconsole.log('the filesystem passed wind');\n}\n}\n</code></pre> <p>We can reasonbly expect that <code>e</code> will be an <code>Error()</code> when we enter the catch block so you might try:</p> <pre><code>catch (e) {\nif (e isinstance Error &amp;&amp; e.code === 'ENOENT') {\n// error TS2339: Property 'code' does not exist on type 'Error'\nconsole.log('prrbt');\n}\n}\n</code></pre> <p>The only thing we know from knowing e is an Error is that it has property Message, and parsing the type of error from that is ugly and bad. We're just interested in <code>e.code</code>. So how do we test if the error has a property <code>code</code>?</p> <p><pre><code>if ('code' in e &amp;&amp; e.code === 'ENOENT') { //    ^ error TS18046: 'e' is of type 'unknown'.\nconsole.log('you get the idea');\n}\n</code></pre> At this point I'm starting to feel like I've missed a trick. I'm using Zod in this project, so I think about validating the error to a custom type, <code>HasCode</code>, but that sounds like ridiculous overkill. Typescript must have a solution to this that doesn't suck.</p> <p>As I later worked out, the reason this throws a Typescript error is that because if <code>e</code> is <code>unknown</code>, then <code>e</code> may be <code>null</code> (or a string, or...) and if you try to check if <code>'property' in null</code> at runtime, things blow up. What you can safely do is check first whether <code>e</code> is the sort of thing that has properties i.e. is <code>e</code> an <code>Object</code>?</p> <pre><code>if (e instanceof Object &amp;&amp; 'code' in e &amp;&amp; e.code === 'ENOENT') {\nconsole.log('oh god that one was wet');\n}\n// &gt; oh god that one was wet\n</code></pre> <p>This works great! First we, check that e is the sort of thing that has properties. Then, we know it has properties, so we see if 'code' is among them. Then, given we know it has properties, and that 'code' is one of them, we can safely access that property and use it for our comparison. Ahhh. </p> <p>Writing this post, I worked out that you don't need to go so generic -- this also works: <pre><code>if (e instanceof Error &amp;&amp; 'code' in e &amp;&amp; e.code === 'ENOENT') {\nconsole.log(\"ok i'm done\");\n}\n// &gt; ok i'm done\n</code></pre></p> <p>This is the type-safe way to do it. You could cast <code>e</code> as <code>Any</code> when it is declared in the catch statement:</p> <pre><code>catch (e: Any) {...}\n</code></pre> <p>but this is forbidden in <code>strict</code> type checking mode for good reason (even though it was the default behaviour in earlier versions of TypeScript) because it completely disables type-checking. </p>"},{"location":"posts/handlingErrorInTS/#tldr","title":"TL;DR","text":"<p>If you want to specifically catch a generic Error with custom properties do something like the below:</p> <p><pre><code>import fs from 'node:fs/promises';\ntry {\nawait fs.readFile('baka');\n}\ncatch (e) {\nif (e instanceof Error &amp;&amp; 'code' in e &amp;&amp; e.code === 'ENOENT') {\nconsole.log('Thanks for reading!!');\n}\n}\n// &gt; Thanks for reading!!\n</code></pre> Bye!</p>"}]}